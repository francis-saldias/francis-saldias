# -*- coding: utf-8 -*-
"""Comparativa LLM-Real.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eUcbqQtE9EBzTHC8gJNbQt5DxVIx1gQf

#Comparativa noticias - precios

##Carga de dfs
"""

import pandas as pd

# Cargar directamente tu archivo que ya está en /content/
df_noticias_predict = pd.read_excel('/content/Analisis_Llama_Noticia.xlsx')
df_noticias_predict = df_noticias_predict.drop(columns=['Unnamed: 0'])
df_noticias_predict

df_precio_cobre = pd.read_excel('/content/Precio_Cobre.xlsx')
df_precio_cobre

"""##Limpiar Dfs"""

df_precio_cobre['Date'] = pd.to_datetime(df_precio_cobre['Date'], format='%Y-%m-%d')
df_precio_cobre['Date'] = df_precio_cobre['Date']
df_precio_filtro = df_precio_cobre[['Date','Change %']]


df_noticias_predict['Fecha (dd/mm/yyyy)'] = pd.to_datetime(
    df_noticias_predict['Fecha (dd/mm/yyyy)'],
    format='%d/%m/%Y'
)

df_noticias_predict['Date'] = df_noticias_predict['Fecha (dd/mm/yyyy)']
df_noticias_filtro = df_noticias_predict[['Date','efecto_modelo']]

df_noticias_filtro

# 1) Mapeo efecto_modelo -> valor numérico
mapa_efecto = {
    'positivo': 1,
    'neutro': 0,
    'negativo': -1}

df_noticias_filtro['efecto_num'] = df_noticias_filtro['efecto_modelo'].map(mapa_efecto)

# 2) Agrupar por fecha y sacar promedio
df_diario = (
    df_noticias_filtro
    .groupby('Date', as_index=False)
    .agg({'efecto_num': 'mean'})
    .rename(columns={'Date': 'Date', 'efecto_num': 'efecto_promedio_num'})
)

# 3) Reclasificar el promedio en clases
def reclasificar_promedio(x):
    if x > 0.3:
        return 'positivo'
    if x < -0.3:
        return 'negativo'
    return 'neutro'

df_diario['efecto_promedio_clase'] = df_diario['efecto_promedio_num'].apply(reclasificar_promedio)

# Ver resultado
print(df_diario.head())
print("Filas antes:", len(df_noticias_filtro), " | Filas después (por día):", len(df_diario))

df_diario

df_precio_filtro

"""##Comparativa sin lags"""

import pandas as pd
from sklearn.metrics import confusion_matrix, classification_report

# 1) Renombrar columnas para facilitar el merge
# df_diario: ['Date', 'efecto_promedio_num', 'efecto_promedio_clase']
# df_precio_filtro: ['Date_Precio', 'Change %']
df_noticias_dia = df_diario.rename(columns={'Date': 'Date'})
df_precios = df_precio_filtro.rename(columns={'Date_Precio': 'Date'})

# 2) Unir por fecha (día 0)
df_merge = pd.merge(df_noticias_dia, df_precios, on='Date', how='left')

# 3) Ordenar por fecha
df_merge = df_merge.sort_values('Date').reset_index(drop=True)

# 4) Preparar serie de precios con cambio del día +1
df_precios_sorted = df_precios.sort_values('Date').reset_index(drop=True)
df_precios_sorted['Change_next'] = df_precios_sorted['Change %'].shift(-1)
df_next = df_precios_sorted[['Date', 'Change_next']]

# 5) Unir para tener, en cada día con noticia, el retorno del día +1
df_final = pd.merge(df_merge, df_next, on='Date', how='left')

# 6) Crear etiqueta REAL según el cambio del día +1
def clasificar_retorno(change):
    if pd.isna(change):
        return None
    if change > 0.0003:
        return 'positivo'
    if change < -0.0003:
        return 'negativo'
    return 'neutro'

df_final['efecto_real'] = df_final['Change_next'].apply(clasificar_retorno)

# 7) Quitar filas sin efecto_real
df_eval = df_final.dropna(subset=['efecto_real'])

# 8) Matriz de confusión y reporte
y_true = df_eval['efecto_real']
y_pred = df_eval['efecto_promedio_clase']

labels = ['positivo', 'neutro', 'negativo']

cm = confusion_matrix(y_true, y_pred, labels=labels)
print("Matriz de confusión (filas = real, columnas = modelo):")
print(pd.DataFrame(cm,
                   index=[f"real_{l}" for l in labels],
                   columns=[f"pred_{l}" for l in labels]))

print("\nReporte de clasificación:")
print(classification_report(y_true, y_pred, labels=labels))

from sklearn.metrics import ConfusionMatrixDisplay
import matplotlib.pyplot as plt

# Crear y mostrar matriz de confusión visual
disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=labels)
disp.plot(cmap="Oranges")  # o el mapa de color que prefieras

plt.title("Matriz de confusión - Variación Real vs Variación Noticias")
plt.xlabel("Predicción Noticias (LLM)")
plt.ylabel("Variación real (Precio Cobre)")
plt.xticks(rotation=45)
plt.tight_layout()

# Guardar como JPG para el póster
plt.savefig("matriz_confusion.jpg", dpi=300, bbox_inches="tight")
plt.show()
